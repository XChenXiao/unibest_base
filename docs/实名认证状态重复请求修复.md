# 实名认证状态重复请求修复方案

## 问题描述

在进入首页时，发现 `/api/verification/status` 请求被发送了两次，造成不必要的网络开销。

## 问题根因分析

### 1. 双重生命周期触发

- 首次进入首页时，`onMounted` 和 `onShow` 几乎同时执行
- 两个生命周期都调用了 `checkVerificationStatusAndShowPopups()`
- 导致 `fetchVerificationStatus()` 被调用两次

### 2. 缺乏防重复机制

- 与公告请求不同，实名认证状态请求没有防重复机制
- 在短时间内连续调用时，无法有效避免重复请求

### 3. 异步竞态条件

- 两次调用间隔很短（从网络截图看约116ms间隔）
- 第一次请求还未完成时，第二次请求已经开始
- Store 中的状态还未更新，导致第二次请求无法被跳过

## 修复方案

### 1. 添加防重复请求机制

```typescript
// 防止短时间内多次请求实名认证状态
let isRequestingVerification = false
let verificationRequestTimer: ReturnType<typeof setTimeout> | null = null

const fetchVerificationStatus = async () => {
  try {
    // 如果正在请求中，直接返回，避免重复请求
    if (isRequestingVerification) {
      console.log('正在请求实名认证状态中，不重复发送请求')
      return verificationStore.isVerified
    }

    // 设置请求标记
    isRequestingVerification = true

    // 清除可能存在的定时器
    if (verificationRequestTimer) {
      clearTimeout(verificationRequestTimer)
    }

    // 执行实际请求逻辑...
  } finally {
    // 设置一个延迟，在这段时间内不再重复请求
    verificationRequestTimer = setTimeout(() => {
      isRequestingVerification = false
    }, 2000) // 2秒内不重复请求
  }
}
```

### 2. 优化页面生命周期逻辑

```typescript
// 标记是否是首次进入页面
const isFirstEnter = ref(true)

// 监听页面显示（每次进入页面都会调用）
onShow(() => {
  console.log('首页被显示')

  // 如果是首次进入，跳过onShow的处理，避免与onMounted重复
  if (isFirstEnter.value) {
    isFirstEnter.value = false
    console.log('首次进入页面，跳过onShow处理避免重复')
    return
  }

  // 后续的页面显示逻辑...
})
```

## 修复效果

### 预期改进

1. **消除重复请求**：确保单次页面访问只发送一次实名认证状态请求
2. **提升性能**：减少不必要的网络请求，提升页面加载速度
3. **改善用户体验**：避免因重复请求导致的延迟和资源浪费

### 验证方法

1. 打开浏览器开发者工具的 Network 面板
2. 清除缓存并刷新页面
3. 观察 `/api/verification/status` 请求，应该只有一次
4. 切换到其他页面再返回首页，验证后续访问的请求情况

## 其他优化建议

### 1. Store 层面的防重复

可以在 `verificationStore` 中也添加类似的防重复机制：

```typescript
// 在 verification store 中
let isRequesting = false

const fetchVerificationStatus = async () => {
  if (isRequesting) {
    console.log('认证状态请求进行中，跳过重复请求')
    return
  }

  isRequesting = true
  try {
    // 执行请求逻辑
  } finally {
    isRequesting = false
  }
}
```

### 2. 全局请求去重

考虑在 HTTP 请求层面实现全局去重机制，自动处理相同的并发请求。

### 3. 缓存策略优化

根据实名认证状态的特点（一旦认证成功，状态相对稳定），可以考虑更长的缓存时间。

## 监控建议

1. 添加请求计数器，监控实名认证状态请求的频率
2. 在控制台输出详细的防重复日志，便于调试
3. 定期检查网络请求，确保优化效果持续有效

## 最终修复方案

经过深入分析，发现问题的根本原因是多个层面的重复调用：

### 1. 首页生命周期重复调用

- `onMounted` 和 `onShow` 同时调用实名认证状态检查
- 通过 `isFirstEnter` 标记避免首次进入时的重复

### 2. 用户管理器重复调用

- `refreshBasicUserData()` 会调用 `userManagerStore.refreshBasicUserData()`
- 该方法内部又会调用 `verificationStore.fetchVerificationStatus()`

### 3. 最终修复代码

```typescript
// 标记是否是首次进入页面
const isFirstEnter = ref(true)

// 防止短时间内多次请求实名认证状态
let isRequestingVerification = false
let verificationRequestTimer: ReturnType<typeof setTimeout> | null = null

// 生命周期
onMounted(() => {
  console.log('首页组件已挂载，准备获取签到数据')
  fetchCheckInData()
  checkVerificationStatusAndShowPopups()
  checkAppUpdate()
})

// 监听页面显示
onShow(() => {
  console.log('首页被显示')

  // 如果是首次进入，跳过onShow的处理，避免与onMounted重复
  if (isFirstEnter.value) {
    isFirstEnter.value = false
    console.log('首次进入页面，跳过onShow处理避免重复')
    return
  }

  // 检查是否是从登录页面跳转而来
  const pages = getCurrentPages()
  const fromLogin = pages.length > 1 && pages[pages.length - 2]?.route?.includes('login')

  if (!fromLogin) {
    // 只刷新签到数据，不触发用户信息或实名认证状态请求
    fetchCheckInData()
  } else {
    console.log('从登录页面跳转而来，跳过所有数据刷新避免重复请求')
  }
})

// 带防重复机制的实名认证状态获取
const fetchVerificationStatus = async () => {
  try {
    if (isRequestingVerification) {
      console.log('正在请求实名认证状态中，不重复发送请求')
      return verificationStore.isVerified
    }

    if (!userStore.isLogined) {
      return false
    }

    if (verificationStore.isVerified) {
      console.log('首页从store中获取到用户已实名认证')
      return true
    }

    isRequestingVerification = true

    if (verificationRequestTimer) {
      clearTimeout(verificationRequestTimer)
    }

    console.log('首页刷新用户实名认证状态')
    await verificationStore.fetchVerificationStatus()

    return verificationStore.isVerified
  } catch (error) {
    console.error('获取实名认证状态失败:', error)
    return false
  } finally {
    verificationRequestTimer = setTimeout(() => {
      isRequestingVerification = false
    }, 2000)
  }
}
```
